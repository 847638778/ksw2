\documentclass{bioinfo}
\copyrightyear{2017}
\pubyear{2017}

\usepackage{amsmath}
\usepackage[ruled,vlined]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\rmfamily{\it #1}}
\SetCommentSty{mycommfont}
\SetKwComment{Comment}{$\triangleright$\ }{}

\usepackage{natbib}
\bibliographystyle{apalike}

\begin{document}
\firstpage{1}

\title[Alignment with DP]{On the implementation of pairwise alignment with dynamic programming}
\author[Li]{Heng Li}
\address{Broad Institute, 415 Main Street, Cambridge, MA 02142, USA}

\maketitle

\begin{abstract}
This \emph{informal} note disambiguates a few different formulations of
pairwise alignment with dynamic programming (DP), investigates the choice of
gap cost function and discusses the implementation of DP-based alignment with a
focus on practical applications. It targets developers who want to grasp
DP-based alignment and implement it to high performance. Importantly, this note
is not a general tutorial. Readers are required to understand the basis of
pairwise alignment before going through the note.
\end{abstract}

\section{Early literature}

\citet{Needleman:1970aa} first proposed to align two biological sequences with
dynamic programming (DP). This is a global alignment algorithm in the sense
that each residue in the pair of sequences is required to be aligned.
\citet{Smith:1981aa} adapted the algorithm to find local hits. They used a
generic \emph{gap cost function} $\gamma(k)$. For two sequences of length $m$
and $n$, respectively, the time complexity to find the optima is
$O(mn\cdot\max\{m,n\})$. \citet{Gotoh:1982aa} showed that when the cost
function takes a form $\gamma(k)=q+k\cdot e$, which is called \emph{affine gap
cost}, it is possible to solve the alignment problem in $O(mn)$ time.
\citet{Altschul:1986aa} fixed an issue in the original Gotoh's algorithm and
introduced the formulation we commonly use today. On more general
gap cost, \citet{Miller:1988aa} devised an $O(mn\log\max\{m,n\})$ algorithm
if $\gamma(k)$ is a concave function. For a piece-wise affine cost composed of
$p$ affine cost functions for different gap lengths, their algorithm could find
the optimal alignment in $O(mn\log p)$ time. \citet{Gotoh:1990aa} proposed an
$O(mn\cdot p)$ algorithm, which is simpler and probably faster for small $p$ in
practice. As the title of Gotoh's paper suggests, piece-wise cost helps
to find long gaps in the alignment.

\section{Alignment with dynamic programming}

In this section, we assume there are two sequences. One is the \emph{target}
sequence or \emph{reference} sequence of length $n$; the other sequence is the
\emph{query} sequence of length $m$. Gaps on the target sequence are
\emph{deletions}; gaps on the query sequence are \emph{insertions}. Function
$s(i,j)$, $0\le i<n$ and $0\le j<m$, gives the score between the $i$-th residue
on the target and the $j$-th residue on the query.

We will focus on global alignment algorithms because it is usually more complex
than local alignment due to non-trivial initial conditions. We will also
briefly touch other types of alignment (e.g. glocal alignment).

\subsection{Linear gap cost}

A linear gap cost function is $\gamma(k;e)=k\cdot e$. Let the optimal score up
to cell $(i,j)$ is $H_{ij}$. The equation to compute $H_{n-1,m-1}$ is:
\begin{equation}\label{eq:linear}
H_{ij}=\left\{\begin{array}{l}
H_{i-1,j-1}+s(i,j) \\
H_{i-1,j}+e \\
H_{i,j-1}+e
\end{array}\right.
\end{equation}

\subsection{Edit distance}

\emph{Edit distance} is the minimum sum of substitutions, insertions and
deletions among all possible alignments between two sequences. It is also
called \emph{Levenshtein distance}~\citep{Levenshtein:1966aa}, though the
author did not provide an algorithm to compute the distance.

Edit distance can be computed with Eq.~(\ref{eq:linear}) if we set matching
score to 0, mismatch score to -1 and $e=1$. Faster algorithms exist.
\citet{Landau:1986aa} found an $O(kn)$ algorithm that guarantees to find
the optimal solution if the edit distance is no larger than $k$. It is
particularly fast if the edit distance is small~\citep{Sosic:2015aa}.

\citet{Myers:1999aa} made an important observation that the difference between
adjacent cells
\[u_{ij}\triangleq H_{ij}-H_{i-1,j}\]
\[v_{ij}\triangleq H_{ij}-H_{i,j-1}\]
only take values $-1$, $0$ or $1$ and can be computed in the diagonal direction
in the DP matrix. This enables bit-level parallelization. Combined with
bounding~\citep{Ukkonen:1985aa}, Myers' algorithm is significantly faster than
the standard algorithm for long sequences. Edlib~\citep{Sosic:2017aa} provides
an efficient implementation of this algorithm with added functionality.
\citet{Loving:2014aa} extended the bit-parallelism to more general integer
scoring. The Suzuki's formulation below was also inspired by
\citet{Myers:1999aa}.

\subsection{Affine gap cost: Durbin's formulation}

For an affine gap cost function $\gamma(k;q,e)=q+k\cdot e$, Durbin's formulation
to derive the pairwise alignment is~\citep{Durbin:1998uq}:
\begin{equation}\label{eq:durbin}
\left\{\begin{array}{l}
M_{ij}=\max\{M_{i-1,j-1}, E_{i-1,j-1}, F_{i-1,j-1}\} + s(i,j)\\
E_{ij}=\max\{M_{i-1,j}-q, E_{i-1,j}\} - e\\
F_{ij}=\max\{M_{i,j-1}-q, F_{i,j-1}\} - e
\end{array}\right.
\end{equation}
This formulation has a natural connection to pair-HMM with each state having a
clear alignment interpretation. It, however, has a problem: it disallows
transitions between $E$ and $F$ states and thus forbids insertions immediately
followed by deletions (and vice versa). When the gap extension cost $e$ is
smaller than a mismatch cost, transitions between $E$ and $F$ may yield a
better alignment score. It is possible to transitions between $E$ and $F$ in
Eq.~(\ref{eq:durbin}), but in practice, AE86's
formulation~\citep{Altschul:1986aa} will be faster to implement.

\subsection{Affine gap cost: AE86's formulation}

In Eq.~(\ref{eq:durbin}), if we let:
\[H_{ij}=\max\{M_{ij},E_{ij},F_{ij}\}\]
Durbin's formulation allowing $E$-$F$ transitions becomes
\begin{equation*}
\left\{\begin{array}{l}
E_{ij}=\max\{H_{i-1,j}-q, E_{i-1,j}\} - e \\
F_{ij}=\max\{H_{i,j-1}-q, F_{i,j-1}\} - e \\
H_{ij}=\max\{H_{i-1,j-1}+S(i,j), E_{ij}, F_{ij}\}
\end{array}\right.
\end{equation*}
This is AE86's formulation. In practice, we often compute the cells in the
following order
\begin{equation}\label{eq:ae86}
\left\{\begin{array}{l}
H_{ij}=\max\{H_{i-1,j-1}+S(i,j), E_{ij}, F_{ij}\}\\
E_{i+1,j}=\max\{H_{ij}-q, E_{i,j}\} - e \\
F_{i,j+1}=\max\{H_{ij}-q, F_{i,j}\} - e
\end{array}\right.
\end{equation}
The initial conditions are
\begin{equation}
\left\{\begin{array}{ll}
H_{-1,-1}=0\\
H_{-1,j}=-q-e-j\cdot e & (0\le j<m)\\
H_{i,-1}=-q-e-i\cdot e & (0\le i<n)\\
E_{0j}=-2q-2e-j\cdot e & (0\le j<m)\\
F_{i0}=-2q-2e-i\cdot e & (0\le i<n)
\end{array}\right.
\end{equation}
We don't need $E_{-1,\cdot}$ or $F_{\cdot,-1}$ because Eq.~(\ref{eq:ae86})
does not start with these initial values. Algorithm~\ref{algo:ae86} gives
the details of AE86.

\begin{algorithm}[tb]
\DontPrintSemicolon
\footnotesize
\KwIn{Targe sequence $T$ and query $Q$; scoring matrix $S(\cdot,\cdot)$ and
affine gap cost $\gamma(k;q,e)=q+k\cdot e$}
\KwOut{Best alignment score between $T$ and $Q$}
\BlankLine
\textbf{Function} {\sc AlignScore}$(T,Q,q,e)$
\Begin {
	\For (\Comment*[f]{Generate query profile}) {$a\in\Sigma$} {
		\For{$j\gets0$ \KwTo $|Q|-1$} {
			$P[a][j]\gets S(Q[j],a)$\;
		}
	}
	\For{$j\gets0$ \KwTo $|Q|-1$} {
		$H[j]\gets-q-j\cdot e$\Comment*[r]{$H[j]=H_{-1,j-1}$}
		$E[j]\gets-2q-2e-j\cdot e$\Comment*[r]{$E[j]=E_{0j}$}
	}
	$H[j]\gets 0$\Comment*[r]{$H_{-1,-1}=0$}
	\For{$i\gets0$ \KwTo $|T|-1$} {
		$f\gets-2q-2e-i\cdot e$\Comment*[r]{$f=F_{i0}$}
		$h\gets-q-e-i\cdot e$\Comment*[r]{$h=H_{i,-1}$}
		$p\gets P[T[i]]$\;
		\For{$j\gets0$ \KwTo $|Q|-1$} {
			$s\gets p[j]$\Comment*[r]{$s=S(Q[j],T[i])$}
			$h'\gets\max\{H[j]+s,E[j],f\}$\;
			$H[j]\gets h$\Comment*[r]{$H[j]=H_{i,j-1}$}
			$h\gets h'$\Comment*[r]{$h=H_{ij}$}
			$E[j]\gets\max\{h-q,E[j]\}-e$\Comment*[r]{$E[j]=E_{i+1,j}$}
			$f\gets\max\{h-q,f\}-e$\Comment*[r]{$f=F_{i,j+1}$}
		}
		$H[|Q|]\gets h$\;
	}
	\Return $H[|Q|]$\;
}
\caption{AE86's formulation with affine gap cost}\label{algo:ae86}
\end{algorithm}

\subsection{Affine gap cost: intra-seq SIMD acceleration}

\subsection{Affine gap cost: Suzuki's formulation}

\subsection{Effect of affine gap cost}

\subsection{Piece-wise affine gap cost}

\bibliography{aln-dp}
\end{document}
